"""
import_items.py
=================

This module provides a helper function to load Turtle‑WoW trade goods
from a saved HTML snapshot.  Rather than scraping the live website
every time—which can lead to 403 Forbidden errors—this importer reads
a local copy of the trade goods page and extracts the relevant
information.

The HTML file contains JavaScript data structures generated by the
Turtle‑WoW database.  Specifically, there is an array assigned to a
`data` property which holds objects with `name` and `id` fields, and
preceding lines that define icon names for each item ID.  This
function parses both constructs with regular expressions to build a
list of items ready for database insertion.

To refresh the item list, simply download a new copy of the page via
a browser, save it to ``data/trade_goods.html``, and call
``load_trade_goods()`` again.  The importer is resilient to minor
formatting differences and ignores any fields it does not recognise.
"""

import json
import os
import re
from typing import Dict, List, Tuple, Any, Iterable, Optional


def load_trade_goods(path: str) -> List[Dict[str, Any]]:
    """Load Turtle‑WoW trade goods from a saved HTML page.

    The Turtle‑WoW item list page embeds an array of item objects in
    JavaScript.  This function reads the HTML file from ``path``,
    extracts that array, parses each object to obtain the item ID
    and name, and matches it with the corresponding icon definition.

    Args:
        path: The filesystem path to the saved HTML file.

    Returns:
        A list of dictionaries.  Each dict contains the following keys:

            * ``item_id`` (int): the numeric item ID.
            * ``name`` (str): the item name as recorded in the list.
            * ``category`` (str): always ``"Trade Goods"`` for this import.
            * ``icon_url`` (str): a URL to the item's icon on the
              Turtle‑WoW database.  If an icon is not defined in the
              HTML, this will be ``""``.
            * ``tooltip_html`` (str): placeholder for a tooltip; left
              empty because tooltips are not present in the snapshot.
    """
    if not os.path.isfile(path):
        raise FileNotFoundError(f"Trade goods HTML file not found: {path}")

    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        content = f.read()

    items: List[Dict[str, Any]] = []
    # ------------------------------------------------------------------
    # Extract icon definitions
    #
    # Before the data array, the HTML file defines icon mappings as
    # assignments of the form `_[12345]={icon: 'INV_Ingot_Thorium'};`.
    # We capture the ID and icon name using regex.  Not every item
    # necessarily has an icon defined this way, so missing IDs will
    # simply get an empty icon URL later.
    icon_pattern = re.compile(r"_\[(\d+)\]=\{\s*icon:\s*'([^']+)'\s*\}")
    icon_map: Dict[str, str] = {}
    for match in icon_pattern.finditer(content):
        item_id, icon_name = match.groups()
        icon_map[item_id] = icon_name

    # ------------------------------------------------------------------
    # Extract the JavaScript array of item objects
    #
    # The page includes a line like:
    #     data: [ {name: 'Rune Thread', description: '', id: 14341, ...}, ... ]
    # inside a call to new Listview().  We locate the array by searching
    # for ``data: [`` and capturing everything up to the closing ``]``.
    data_match = re.search(r"data:\s*\[(.*?)]\s*\}\);", content, flags=re.DOTALL)
    if not data_match:
        # If the array cannot be found, return an empty list.
        return items

    data_section = data_match.group(1)

    # Each object in the array is separated by ``},``.  We split on
    # ``},{`` to get individual object strings.  Since there may be nested
    # braces in other fields, we use a simple approach assuming there are
    # no nested braces in the object definitions relevant to us.
    # After splitting, we re-add the closing ``}`` to each element.
    raw_entries = [entry + "}" for entry in data_section.split("},{")]

    # Pattern to capture name and id from each object.  The item names
    # are single‑quoted and may contain escaped quotes (e.g. \' inside
    # strings).  We use a tempered dot to avoid crossing into braces.
    name_id_pattern = re.compile(r"name:\s*'(?P<name>[^']*)'.*?id:\s*(?P<id>\d+)", re.DOTALL)

    for raw in raw_entries:
        m = name_id_pattern.search(raw)
        if not m:
            continue
        name = m.group("name").strip()
        item_id = m.group("id").strip()
        # Build full icon URL if available
        icon_name = icon_map.get(item_id)
        icon_url = (
            f"https://database.turtle-wow.org/images/icons/{icon_name}.png"
            if icon_name
            else ""
        )
        # Remove any leading quantity digits from the name.  Some names in
        # the snapshot start with a number (e.g. '5Rune Thread'); we
        # discard this prefix for cleaner display.  If the name
        # legitimately begins with a digit, this will strip it; adjust
        # logic if that proves problematic.
        clean_name = re.sub(r"^\d+", "", name).lstrip()
        items.append(
            {
                "item_id": int(item_id),
                "name": clean_name,
                "category": "Trade Goods",
                "icon_url": icon_url,
                "tooltip_html": "",
            }
        )

    return items