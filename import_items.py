"""
import_items.py
=================

This module provides a helper function to load Turtle‑WoW trade goods
from a saved HTML snapshot.  Rather than scraping the live website
every time—which can lead to 403 Forbidden errors—this importer reads
a local copy of the trade goods page and extracts the relevant
information.

The HTML file contains JavaScript data structures generated by the
Turtle‑WoW database.  Specifically, there is an array assigned to a
`data` property which holds objects with `name` and `id` fields, and
preceding lines that define icon names for each item ID.  This
function parses both constructs with regular expressions to build a
list of items ready for database insertion.

To refresh the item list, simply download a new copy of the page via
a browser, save it to ``data/trade_goods.html``, and call
``load_trade_goods()`` again.  The importer is resilient to minor
formatting differences and ignores any fields it does not recognise.
"""

import json
import os
import re
from typing import Dict, List, Tuple, Any, Iterable, Optional


def load_trade_goods(path: str) -> List[Dict[str, Any]]:
    """Load Turtle‑WoW trade goods from a saved HTML page.

    The Turtle‑WoW item list page embeds an array of item objects in
    JavaScript.  This function reads the HTML file from ``path``,
    extracts that array, parses each object to obtain the item ID
    and name, and matches it with the corresponding icon definition.

    Args:
        path: The filesystem path to the saved HTML file.

    Returns:
        A list of dictionaries.  Each dict contains the following keys:

            * ``item_id`` (int): the numeric item ID.
            * ``name`` (str): the item name as recorded in the list.
            * ``category`` (str): always ``"Trade Goods"`` for this import.
            * ``icon_url`` (str): a URL to the item's icon on the
              Turtle‑WoW database.  If an icon is not defined in the
              HTML, this will be ``""``.
            * ``tooltip_html`` (str): placeholder for a tooltip; left
              empty because tooltips are not present in the snapshot.
    """
    # Check that the file exists before attempting to open it.  We
    # deliberately raise a FileNotFoundError here so callers can
    # handle the error gracefully or log a helpful message.  Using
    # os.path.isfile() allows both relative and absolute paths.
    if not os.path.isfile(path):
        raise FileNotFoundError(f"Trade goods HTML file not found: {path}")

    # Read the entire HTML content into memory.  If the file is
    # extremely large this could be memory intensive, but the
    # Turtle‑WoW item pages are well within reasonable limits.
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        content = f.read()

    items: List[Dict[str, Any]] = []
    # ------------------------------------------------------------------
    # Extract icon definitions
    #
    # Before the data array, the HTML file defines icon mappings as
    # assignments of the form `_[12345]={icon: 'INV_Ingot_Thorium'};`.
    # We capture the ID and icon name using regex.  Not every item
    # necessarily has an icon defined this way, so missing IDs will
    # simply get an empty icon URL later.
    icon_pattern = re.compile(r"_\[(\d+)\]=\{\s*icon:\s*'([^']+)'\s*\}")
    icon_map: Dict[str, str] = {}
    for match in icon_pattern.finditer(content):
        item_id, icon_name = match.groups()
        icon_map[item_id] = icon_name

    # ------------------------------------------------------------------
    # Extract the JavaScript array of item objects
    #
    # The page includes a line like:
    #     data: [ {name: 'Rune Thread', description: '', id: 14341, ...}, ... ]
    # inside a call to new Listview().  We locate the array by searching
    # for ``data: [`` and capturing everything up to the closing ``]``.
    data_match = re.search(r"data:\s*\[(.*?)]\s*\}\);", content, flags=re.DOTALL)
    if not data_match:
        # If the array cannot be found, return an empty list.
        return items

    data_section = data_match.group(1)

    # Each object in the array is separated by ``},``.  We split on
    # ``},{`` to get individual object strings.  Since there may be nested
    # braces in other fields, we use a simple approach assuming there are
    # no nested braces in the object definitions relevant to us.
    # After splitting, we re-add the closing ``}`` to each element.
    raw_entries = [entry + "}" for entry in data_section.split("},{")]

    # Pattern to capture name and id from each object.  The item names
    # are single‑quoted and may contain escaped quotes (e.g. \' inside
    # strings).  We use a tempered dot to avoid crossing into braces.
    name_id_pattern = re.compile(r"name:\s*'(?P<name>[^']*)'.*?id:\s*(?P<id>\d+)", re.DOTALL)

    for raw in raw_entries:
        m = name_id_pattern.search(raw)
        if not m:
            continue
        name = m.group("name").strip()
        item_id = m.group("id").strip()
        # Build full icon URL if available
        icon_name = icon_map.get(item_id)
        icon_url = (
            f"https://database.turtle-wow.org/images/icons/{icon_name}.png"
            if icon_name
            else ""
        )
        # Remove any leading quantity digits from the name.  Some names in
        # the snapshot start with a number (e.g. '5Rune Thread'); we
        # discard this prefix for cleaner display.  If the name
        # legitimately begins with a digit, this will strip it; adjust
        # logic if that proves problematic.
        clean_name = re.sub(r"^\d+", "", name).lstrip()
        items.append(
            {
                "item_id": int(item_id),
                "name": clean_name,
                "category": "Trade Goods",
                "icon_url": icon_url,
                "tooltip_html": "",
            }
        )

    return items

# ---------------------------------------------------------------------------
# Command‑line interface
#
# When run directly (e.g. ``python import_items.py``), this module will
# attempt to load the trade goods from a specified HTML file and print
# summary information.  Use this to test the importer and diagnose
# problems with missing files or parsing errors.  Logging messages
# provide feedback on success or failure.

if __name__ == "__main__":
    import argparse
    import logging
    # Configure a basic logger.  When imported as a module this
    # configuration has no effect because __main__ is not executed.
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s %(levelname)s %(message)s",
    )
    parser = argparse.ArgumentParser(
        description="Load Turtle‑WoW trade goods from an HTML snapshot."
    )
    parser.add_argument(
        "path",
        nargs="?",
        default="data/trade_goods.html",
        help="Path to the saved trade_goods.html file (default: data/trade_goods.html)",
    )
    args = parser.parse_args()
    path = args.path
    try:
        items = load_trade_goods(path)
        logging.info(
            "Successfully loaded %d items from %s", len(items), path
        )
        # Print the first few items for quick verification at debug level.
        for itm in items[:10]:
            logging.debug("%5d  %s", itm["item_id"], itm["name"])
    except FileNotFoundError as fnfe:
        logging.error(fnfe)
        logging.info(
            "Ensure the HTML snapshot exists at the specified path. "
            "If not, download the page and save it there."
        )
    except Exception as ex:
        logging.error("Unexpected error while loading trade goods: %s", ex)